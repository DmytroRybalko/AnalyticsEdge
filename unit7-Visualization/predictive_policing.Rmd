---
title: "Predictive Policing"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(ggplot2)
library(maps)
library(ggmap)
```

Load our data:
```{r}
mvt <- read.csv("mvt.csv", stringsAsFactors = FALSE)
str(mvt)
```

Convert the Date variable to a format that R will recognize:
```{r}
mvt$Date <- strptime(mvt$Date, format="%m/%d/%y %H:%M")
```

Extract the hour and the day of the week:
```{r}
mvt$Weekday <- weekdays(mvt$Date)
mvt$Hour <- mvt$Date$hour
```

Let's take a look at the structure of our data again:
```{r}
str(mvt)
```

Create a simple line plot - need the total number of crimes on each day of the week. We can get this information by creating a table:
```{r}
table(mvt$Weekday)
```

Save this table as a data frame:
```{r}
WeekdayCounts <- as.data.frame(table(mvt$Weekday))
str(WeekdayCounts) 
```

Create our plot
```{r}
ggplot(WeekdayCounts, aes(x = Var1, y = Freq)) + geom_line(aes(group = 1))  
```

Make the "Var1" variable an ORDERED factor variable
```{r}
WeekdayCounts$Var1 <- factor(WeekdayCounts$Var1,
                            ordered = TRUE,
                            levels = c("Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday","Saturday"))
```

Try again:
```{r}
ggplot(WeekdayCounts, aes(x = Var1, y = Freq)) + geom_line(aes(group = 1))
```

Change our x and y labels:
```{r}
ggplot(WeekdayCounts, aes(x = Var1, y = Freq)) +
  geom_line(aes(group = 1)) +
  xlab("Day of the Week") +
  ylab("Total Motor Vehicle Thefts")
```

# QQ

Create a new line plot, like the one in Video 3, but add the argument "linetype=2". So the geom_line part of the plotting command should look like:
```{r}
ggplot(WeekdayCounts, aes(x = Var1, y = Freq)) +
  geom_line(aes(group = 1), linetype = 2)
```

What does this do?  
  
Now, change the alpha parameter to 0.3 by replacing "linetype=2" with "alpha=0.3" in the plot command. What does this do?
```{r}
ggplot(WeekdayCounts, aes(x = Var1, y = Freq)) +
  geom_line(aes(group = 1), alpha = 0.3)
```

In this video, we'll add the hour of the day to our line plot, and then create an alternative visualization using a heat map. We can do this by creating a line for each day of the week and making the x-axis the hour of the day. We first need to create a counts table for the weekday, and hour.
So we'll use the table function and give as the first variable, the Weekday variable in our data frame and as the second variable, the Hour variable.  
```{r}
# Create a counts table for the weekday and hour:
table(mvt$Weekday, mvt$Hour)
```

This table gives, for each day of the week and each hour, the total number of motor vehicle thefts that occurred. For example, on Friday at 4 AM, there were 473 motor vehicle thefts, whereas on Saturday at midnight, there were 2,050 motor vehicle thefts. Let's save this table to a data frame
so that we can use it in our visualizations. We'll call it DayHourCounts and use the as.data.frame function, run on our table, where the first variable is the Weekday and the second variable is the Hour.  
```{r}
# Save this to a data frame:
DayHourCounts <- as.data.frame(table(mvt$Weekday, mvt$Hour))
str(DayHourCounts)
```

We can see that we have 168 observations - one for each day of the week and hour pair, and three different variables. The first variable, Var1, gives the day of the week. The second variable, Var2, gives the hour of the day. And the third variable, Freq for frequency, gives the total crime count.
Let's convert the second variable, Var2, to actual numbers and call it Hour, since this is the hour of the day, and it makes sense that it's numerical. So we'll add a new variable to our data frame called 
```{r}
# Convert the second variable, Var2, to numbers and call it Hour:
DayHourCounts$Hour <- as.numeric(as.character(DayHourCounts$Var2))
```

This is how we convert a factor variable to a numeric variable. Now we're ready to create our plot. We just need to change the group to Var1, which is the day of the week. So we'll use the ggplot function where our data frame is DayHourCounts, and then in our aesthetic, we want the x-axis to be Hour this time, the y-axis to be Freq, and then in the geom_line option, like we used in the previous video, we want the aesthetic to have the group equal to Var1, which is the day of the week.  
```{r}
# Create out plot:
ggplot(DayHourCounts, aes(x = Hour, y = Freq)) + geom_line(aes(group = Var1))
```

You should see a new plot show up in the graphics window. It has seven lines, one for each day of the week. While this is interesting, we can't
tell which line is which day, so let's change the colors of the lines to correspond to the days of the week.
```{r}
# Change the colors
ggplot(DayHourCounts, aes(x = Hour, y = Freq)) + geom_line(aes(group = Var1, color = Var1), size = 2)
```

Now in our plot, each line is colored corresponding to the day of the week. This helps us see that on Saturday and Sunday, for example, the green and the teal lines, there's less motor vehicle thefts in the morning. While we can get some information from this plot, it's still quite hard to interpret. Seven lines is a lot. Let's instead visualize the same information with a heat map.  
  
To make a heat map, we'll use our data in our data frame DayHourCounts. First, though, we need to fix the order of the days so that they'll show up in chronological order instead of in alphabetical order. We'll do the same thing we did in the previous video. So for DayHourCounts\$Var1, which is the day of the week, we're going to use the factor function where the first argument is our variable, DayHourCounts$Var1, the second argument is ordered = TRUE, and the third argument is the order we want the days of the week to show up in. So we'll set levels, equals, and then c, and then list your days of the week. Let's put the weekdays first and the weekends at the end. So we'll start with Monday, and then Tuesday, then Wednesday, then Thursday, Friday, Saturday and Sunday.
```{r}
# Fix the order of the days:
DayHourCounts$Var1 <- factor(DayHourCounts$Var1,
                             ordered = TRUE,
                             levels = c("Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"))
```

Make a heatmap:
```{r}
ggplot(DayHourCounts, aes(x = Hour, y = Var1)) + geom_tile(aes(fill = Freq))
```

For each hour and each day of the week, we have a rectangle in our heat map. The color of that rectangle indicates the frequency, or the number of crimes that occur in that hour and on that day. Our legend tells us that lighter colors correspond to more crime. So we can see that a lot of crime happens around midnight, particularly on the weekends.

```{r}
# Change the label on the legend, and get rid of the y-label:
ggplot(DayHourCounts, aes(x = Hour, y = Var1)) + geom_tile(aes(fill = Freq)) + scale_fill_gradient(name="Total MV Thefts") + theme(axis.title.y = element_blank())
```

We can also change the color scheme. We can do this by scrolling up in our R console, and going to that scale_fill_gradient function, the one that defines properties of our legend, and after name = "Total MV Thefts", low = "white", high = "red". We'll make lower values correspond to white colors and higher values correspond to red colors.
```{r}
# Change the color scheme
ggplot(DayHourCounts, aes(x = Hour, y = Var1)) + geom_tile(aes(fill = Freq)) + scale_fill_gradient(name="Total MV Thefts", low="white", high="red") + theme(axis.title.y = element_blank())
```

This is a common color scheme in policing. It shows the hot spots, or the places with more crime, in red. So now the most crime is shown by the red spots
and the least crime is shown by the lighter areas. It looks like Friday night is a pretty common time for motor vehicle thefts. We saw something that we didn't really see in the heat map before. It's often useful to change the color scheme depending on whether you want high values or low values to pop out, and the feeling you want the plot to portray. In this video, we've seen how to create some new types of plots. In the next video, we'll see how to add data to geographical maps.  

# A Geographical Hot Spot Map  

In this video, we'll plot crime on a map of Chicago.  
Now, let's load a map of Chicago into R. We can easily do this by using the get_map function.  
```{r}
#register_google(key = "AIzaSyCj9BsAyfgVtQZuY4sHHqly9AEo2o1RJ2U")
#chicago <- get_map(location = c(-87.8720469, 41.8339037), zoom = 11)
```
Alternative way
```{r}
chi_bb <- c(left = -87.87, bottom = 41.7, right = -87.4, top = 42.04)
chicago <- get_stamenmap(bbox = chi_bb, zoom = 11)
ggmap(chicago)
```

```{r}
# Plot the first 100 motor vehicle thefts:
ggmap(chicago) + geom_point(data = mvt[1:100,], aes(x = Longitude, y = Latitude))
```

Now, in your R graphics window, you should see the map of Chicago with black points marking where the first 100 motor vehicle thefts were. If we plotted all 190,000 motor vehicle thefts, we would just see a big black box, which wouldn't be helpful at all. We're more interested in whether or not an area has a high amount of crime, so let's round our latitude and longitude to two digits of accuracy and create a crime counts data frame for each area.  

```{r}
# Round our latitude and longitude to 2 digits of accuracy, and create a crime counts data frame for each area:
LatLonCounts <- as.data.frame(table(round(mvt$Longitude,2), round(mvt$Latitude,2)))
str(LatLonCounts)
```

This gives us the total crimes at every point on a grid. Let's take a look at our data frame using the str function.  
```{r}
# Convert our Longitude and Latitude variable to numbers:
LatLonCounts$Long <- as.numeric(as.character(LatLonCounts$Var1))
LatLonCounts$Lat <- as.numeric(as.character(LatLonCounts$Var2))
```

# Plot these points on our map:
```{r}
ggmap(chicago) + geom_point(data = LatLonCounts, aes(x = Long, y = Lat, color = Freq, size=Freq))
```

Now, in our R graphics window, our plot should have a point for every area defined by our latitude and longitude areas, and the points have a size and color corresponding to the number of crimes in that area. So we can see that the lighter and larger points correspond to more motor vehicle thefts. This helps us see where in Chicago more crimes occur.

```{r}
# Change the color scheme:
ggmap(chicago) + geom_point(data = LatLonCounts, aes(x = Long, y = Lat, color = Freq, size=Freq)) +
  scale_colour_gradient(low="yellow", high="red")
```

We can also use the geom_tile geometry
```{r}
ggmap(chicago) + geom_tile(data = LatLonCounts, aes(x = Long, y = Lat, alpha = Freq), fill="red")
```

This will define how to scale the colors on the heat map according to the crime counts. Then close the parentheses and type a comma, and then type fill="red", defining our color scheme. Close the parentheses and hit Enter. This map takes a minute to load. While we're waiting, let's discuss
what we've done in this video. We've created a geographical heat map, which in our case shows a visualization of the data, but it could also show the predictions of a model. Now that our heat map is loaded, let's take a look. In each area of Chicago, now that area is colored in red by the amount of crime there. This looks more like a map that people use for predictive policing.  

# QQ  

```{r}
LatLonCounts2 <- subset(LatLonCounts, LatLonCounts$Freq > 0)
```

# A Heatmap on the United States

In this video, we'll create a heat map on a map of the United States. We'll be using the data set murders.csv, which is data provided by the FBI giving the total number of murders in the United States by state. Let's start by reading in our data set.
```{r}
# Load our data:
murders <- read.csv("murders.csv")
str(murders)
```

# Load the map of the US
```{r}
statesMap <- map_data("state")
str(statesMap)
```

To plot the map, we'll use the polygons geometry of ggplot. So type ggplot, and then in parentheses, our data frame is statesMap, and then our aesthetic is x = long, the longitude variable in statesMap, y = lat, the latitude variable, and then group = group. This is the variable defining how to draw the United States into groups by state. Then close both parentheses here, and we'll add geom_polygon where our arguments here will be
fill="white"-- we'll just fill all states in white -- and color="black" to outline the states in black. Now in your R graphics window, you should see a map of the United States.  

# Plot the map:
```{r}
ggplot(statesMap, aes(x = long, y = lat, group = group)) +
  geom_polygon(fill = "white", color = "black") 
```

Create a new variable called region with the lowercase names to match the statesMap:
```{r}
murders$region <- tolower(murders$State)
```

Join the statesMap data and the murders data into one dataframe:
```{r}
murderMap <- merge(statesMap, murders, by = "region")
str(murderMap)
```

We have the same number of observations here that we had in the statesMap data frame, but now we have both the variables from the statesMap data frame and the variables from the murders data frame, which were matched up based on the region variable. So now, let's plot the number of murders
on our map of the United States.

# Plot the number of murder on our map of the United States:
```{r}
ggplot(murderMap, aes(x = long, y = lat, group = group, fill = Murders)) +
  geom_polygon(color = "black") +
  scale_fill_gradient(low = "black", high = "red", guide = "legend")
```

If you hit Enter and look at your graphics window now, you should see that each of the states is colored by the number of murders in that state.
States with a larger number of murders are more red. So it looks like California and Texas have the largest number of murders. But is that just because they're the most populous states? Let's create a map of the population of each state to check.

```{r}
# Plot a map of the population:
ggplot(murderMap, aes(x = long, y = lat, group = group, fill = Population)) +
  geom_polygon(color = "black") +
  scale_fill_gradient(low = "black", high = "red", guide = "legend")
```

If you look at the graphics window, we have a population map here which looks exactly the same as our murders map. So we need to plot the murder rate instead of the number of murders to make sure we're not just plotting a population map.  

Create a new variable that is the number of murders per 100,000 population:
```{r}
murderMap$MurderRate <- murderMap$Murders / murderMap$Population * 100000
```

Redo our plot with murder rate:
```{r}
ggplot(murderMap, aes(x = long, y = lat, group = group, fill = MurderRate)) +
  geom_polygon(color = "black") +
  scale_fill_gradient(low = "black", high = "red", guide = "legend")
```

If you look at your graphics window now, you should see that the plot is surprisingly maroon-looking. There aren't really any red states. Why?
It turns out that Washington, DC is an outlier with a very high murder rate, but it's such a small region on the map that we can't even see it.
So let's redo our plot, removing any observations with murder rates above 10, which we know will only exclude Washington, DC. Keep in mind that when interpreting and explaining the resulting plot, you should always note what you did to create it: removed Washington, DC from the data.

Redo the plot, removing any states with murder rates above 10:
```{r}
ggplot(murderMap, aes(x = long, y = lat, group = group, fill = MurderRate)) +
  geom_polygon(color = "black") +
  scale_fill_gradient(low = "black", high = "red", guide = "legend", limits = c(0,10))
```

# QQ

```{r}
ggplot(murderMap, aes(x = long, y = lat, group = group, fill = GunOwnership)) +
  geom_polygon(color = "black") +
  scale_fill_gradient(low = "black", high = "red", guide = "legend", limits = c(0,10))
```


